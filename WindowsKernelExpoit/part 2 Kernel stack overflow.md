***Windows kernel exploit analysis series part 2 Kernel stack overfolow**
		by 妖孽
1，

触发内核栈溢出的代码如下：

    NTSTATUS
	TriggerBufferOverflowStack(
	    _In_ PVOID UserBuffer,
	    _In_ SIZE_T Size
	)
	{
	    NTSTATUS Status = STATUS_SUCCESS;
	    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };

    PAGED_CODE();

    __try
    {
        //
        // Verify if the buffer resides in user mode
        //

        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%X\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%X\n", sizeof(KernelBuffer));

	
        //
        // Secure Note: This is secure because the developer is passing a size
        // equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,
        // there will be no overflow
        //

        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));
	
        DbgPrint("[+] Triggering Buffer Overflow in Stack\n");

        //
        // Vulnerability Note: This is a vanilla Stack based Overflow vulnerability
        // because the developer is passing the user supplied size directly to
        // RtlCopyMemory()/memcpy() without validating if the size is greater or
        // equal to the size of KernelBuffer
        // 没有验证3环来的数据的长度是否小于等于KernelBuffer缓冲区的长度
		*************此处拷贝3环来的数据到内核栈中，没有对拷贝长度进行限制，导致返回地址被覆盖
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
	
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}