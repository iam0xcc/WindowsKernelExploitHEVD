# Windows kernel exploit analysis series part 5 空指针解引用 #
by 妖孽

1，空指针解引用漏洞原理

内核中有一个类似NULL_POINTER_DEREFERENCE的指针A，我把A释放掉以后，仍然继续调用A指针内部的Callback函数。如果把A指针设置为NULL，那么调用内部的Callback函数就会发生蓝屏。

问题1，如果后续被释放的内存被别人申请到以后，内容可能会发生变化，所以再内核里面调用Callback的时候会发生蓝屏等等问题。

问题2，A指针被设置为NULL，A指向的地址就是0地址，如果我在0地址上申请内存，那么0地址就是可访问的，设置Callback指针为shellcode指针，这就是空指针解引用漏洞的利用原理。
注意0地址，是应用层的地址，通过iocontrol调用的时候，当前线程仍然是当前进程的。

	typedef struct _NULL_POINTER_DEREFERENCE
	{
		ULONG Value;
		FunctionPointer Callback;函数指针
	} NULL_POINTER_DEREFERENCE, *PNULL_POINTER_DEREFERENCE;

************************************************************

   	NTSTATUS
	TriggerNullPointerDereference(
   		 _In_ PVOID UserBuffer
	)
	{
    ULONG UserValue = 0;
    ULONG MagicValue = 0xBAD0B0B0;
    NTSTATUS Status = STATUS_SUCCESS;
    PNULL_POINTER_DEREFERENCE NullPointerDereference = NULL;

    PAGED_CODE();
    __try
    {
        // Verify if the buffer resides in user mode

        ProbeForRead(UserBuffer, sizeof(NULL_POINTER_DEREFERENCE), (ULONG)__alignof(UCHAR));

        // Allocate Pool chunk

        NullPointerDereference = (PNULL_POINTER_DEREFERENCE)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(NULL_POINTER_DEREFERENCE),
            (ULONG)POOL_TAG
        );

        if (!NullPointerDereference)
        {
            // Unable to allocate Pool chunk
            DbgPrint("[-] Unable to allocate Pool chunk\n");

            Status = STATUS_NO_MEMORY;
            return Status;
        }
        else
        {
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Type: %s\n", STRINGIFY(NonPagedPool));
            DbgPrint("[+] Pool Size: 0x%X\n", sizeof(NULL_POINTER_DEREFERENCE));
            DbgPrint("[+] Pool Chunk: 0x%p\n", NullPointerDereference);
        }

        //
        // Get the value from user mode
        //

        UserValue = *(PULONG)UserBuffer;

        DbgPrint("[+] UserValue: 0x%p\n", UserValue);
        DbgPrint("[+] NullPointerDereference: 0x%p\n", NullPointerDereference);

        //
        // Validate the magic value
        //

        if (UserValue == MagicValue)
        {
            NullPointerDereference->Value = UserValue;
            NullPointerDereference->Callback = &NullPointerDereferenceObjectCallback;

            DbgPrint("[+] NullPointerDereference->Value: 0x%p\n", NullPointerDereference->Value);
            DbgPrint("[+] NullPointerDereference->Callback: 0x%p\n", NullPointerDereference->Callback);
        }
        else
        {
            DbgPrint("[+] Freeing NullPointerDereference Object\n");
            DbgPrint("[+] Pool Tag: %s\n", STRINGIFY(POOL_TAG));
            DbgPrint("[+] Pool Chunk: 0x%p\n", NullPointerDereference);

            //
            // Free the allocated Pool chunk
            //

            ExFreePoolWithTag((PVOID)NullPointerDereference, (ULONG)POOL_TAG);

            //
            // Set to NULL to avoid dangling pointer
            //
			// 设置NullPointerDereference指针为NULL
            NullPointerDereference = NULL;
        }

	#ifdef SECURE
        //
        // Secure Note: This is secure because the developer is checking if
        // 'NullPointerDereference' is not NULL before calling the callback function
        //

        if (NullPointerDereference)
        {
            NullPointerDereference->Callback();
        }
	#else
        DbgPrint("[+] Triggering Null Pointer Dereference\n");

        //
        // Vulnerability Note: This is a vanilla Null Pointer Dereference vulnerability
        // because the developer is not validating if 'NullPointerDereference' is NULL
        // before calling the callback function
        //
		//这里的NullPointerDereference的值为0，但是我申请了0地址内存，那么就会调用到这里
        NullPointerDereference->Callback();
	#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}
2，漏洞利用

通过申请0地址内存，让NullPointerDereference可以通过指针进行访问。


3，补丁修复

NullPointerDereference被释放，设置为NULL后，要再次先判断NullPointerDereference是否为NULL再调用。

        if (NullPointerDereference)
        {
            NullPointerDereference->Callback();
        }

